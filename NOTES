set up page fault handler on page writes: mprotect(PROT_READ) -> ioctl(uffd, UFFDIO_WRITEPROTECT, struct *uffdio_writeprotect { mode = UFFDIO_REGISTER_MODE_WP; })
mprotect(PROT_READ|PROT_WRITE) 

// open userfaultfd
#ifdef UFFD_USER_MODE_ONLY
// Post-Linux 5.11, UFFD_USER_MODE_ONLY needs to be specified if sysctl vm.unprivileged_userfaultfd == 2
// https://lore.kernel.org/lkml/20201120030411.2690816-2-lokeshgidra@google.com/
c3_i fal_i = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK | UFFD_USER_MODE_ONLY); // TODO: does it need O_NONBLOCK?
if ( -1 == fal_i && EINVAL == errno ) {
    // We could just be on an older kernel, try again without UFFD_USER_MODE_ONLY
    fal_i = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
} 
#else
c3_i fal_i = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
#endif
if ( -1 == fal_i ) { err; }

struct uffdio_api ape_u;
ape_u.api = UFFD_API;
ape_u.features = UFFD_FEATURE_PAGEFAULT_FLAG_WP;
// TODO: is this checking features correctly

// handshake: tell Linux API version, EINVAL if not supported
// handshake: check Linux supports UFFDIO_REGISTER_MODE_WP
if ( -1 == ioctl(fal_i, UFFDIO_API, &ape_u)
   || 0 == (ape_u.features & UFFD_FEATURE_PAGEFAULT_FLAG_WP)
   || 0 == (ape_u.ioctls & (1 << _UFFDIO_WRITEPROTECT)) )
{
  err "please upgrade to Linux 5.7 or later";
}

) { err; }
if ( 0 == (ape_u.ioctls & (1 << _UFFDIO_WRITEPROTECT)) ) {

// register the fd to send events on write of write-protected pages within loom
struct uffdio_register reg_u {
    .range.start = ?
    .range.end = ?
    .mode = UFFDIO_REGISTER_MODE_WP;
    .ioctls = 0;
}
if ( -1 == ioctl(fal_i, UFFDIO_REGISTER, &reg_u) || 0 == reg_u.ioctls ) { err; }

// launch thread to handle page faults
pthread_t ted_u;
// TODO: second argument, pthread_attr_t?
pthread_create(&ted_u, NULL, u3e_fault_thread, (void*)fal_i);


UFFD_FEATURE_PAGEFAULT_FLAG_WP

in fault handler:
# ifdef DEBUG_MM
assert(msg.arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_WP)
# endif

from `linux/Documentation/admin-guide/mm/userfaultfd.rst`:

Write Protect Notifications
---------------------------

This is equivalent to (but faster than) using mprotect and a SIGSEGV
signal handler.

Firstly you need to register a range with ``UFFDIO_REGISTER_MODE_WP``.
Instead of using mprotect(2) you use
``ioctl(uffd, UFFDIO_WRITEPROTECT, struct *uffdio_writeprotect)``
while ``mode = UFFDIO_WRITEPROTECT_MODE_WP``
in the struct passed in.  The range does not default to and does not
have to be identical to the range you registered with.  You can write
protect as many ranges as you like (inside the registered range).
Then, in the thread reading from uffd the struct will have
``msg.arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_WP`` set. Now you send
``ioctl(uffd, UFFDIO_WRITEPROTECT, struct *uffdio_writeprotect)``
again while ``pagefault.mode`` does not have ``UFFDIO_WRITEPROTECT_MODE_WP``
set. This wakes up the thread which will continue to run with writes. This
allows you to do the bookkeeping about the write in the uffd reading
thread before the ioctl.

If you registered with both ``UFFDIO_REGISTER_MODE_MISSING`` and
``UFFDIO_REGISTER_MODE_WP`` then you need to think about the sequence in
which you supply a page and undo write protect.  Note that there is a
difference between writes into a WP area and into a !WP area.  The
former will have ``UFFD_PAGEFAULT_FLAG_WP`` set, the latter
``UFFD_PAGEFAULT_FLAG_WRITE``.  The latter did not fail on protection but
you still need to supply a page when ``UFFDIO_REGISTER_MODE_MISSING`` was
used.
